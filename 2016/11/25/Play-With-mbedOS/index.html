<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://muddog.github.io">
  <title>玩转mbedOS | MudDog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="mbedOS是ARM自己打造、主打IoT的一整套软件解决方案，是一个针对ARM CortexM系列处理器的嵌入式开源生态。详细的一些介绍可以参见我的另一篇文章《IoT的那些操作系统》从日常的工作、及和其他支持部门的交流来看，mbedOS现在还处于成长和推广阶段，在国内正真使用的客户貌似还很少，国外确实有比较牛X的客户指名道姓需要NXP的硬件来支持mbedOS。本人还是比较看好mbed，毕竟亲爹是A">
<meta property="og:type" content="article">
<meta property="og:title" content="玩转mbedOS">
<meta property="og:url" content="http://muddog.github.io/2016/11/25/Play-With-mbedOS/index.html">
<meta property="og:site_name" content="MudDog">
<meta property="og:description" content="mbedOS是ARM自己打造、主打IoT的一整套软件解决方案，是一个针对ARM CortexM系列处理器的嵌入式开源生态。详细的一些介绍可以参见我的另一篇文章《IoT的那些操作系统》从日常的工作、及和其他支持部门的交流来看，mbedOS现在还处于成长和推广阶段，在国内正真使用的客户貌似还很少，国外确实有比较牛X的客户指名道姓需要NXP的硬件来支持mbedOS。本人还是比较看好mbed，毕竟亲爹是A">
<meta property="og:image" content="https://docs.mbed.com/docs/debugging-on-mbed/en/latest/Debugging/Images/PyOCD1.png">
<meta property="og:updated_time" content="2017-01-02T05:17:16.513Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="玩转mbedOS">
<meta name="twitter:description" content="mbedOS是ARM自己打造、主打IoT的一整套软件解决方案，是一个针对ARM CortexM系列处理器的嵌入式开源生态。详细的一些介绍可以参见我的另一篇文章《IoT的那些操作系统》从日常的工作、及和其他支持部门的交流来看，mbedOS现在还处于成长和推广阶段，在国内正真使用的客户貌似还很少，国外确实有比较牛X的客户指名道姓需要NXP的硬件来支持mbedOS。本人还是比较看好mbed，毕竟亲爹是A">
<meta name="twitter:image" content="https://docs.mbed.com/docs/debugging-on-mbed/en/latest/Debugging/Images/PyOCD1.png">
  
    <link rel="alternative" href="/atom.xml" title="MudDog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">豆芽</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">Home</a></li>
	        
				<li><a href="/tags/IoT">IoT</a></li>
	        
				<li><a href="/tags/embeded">Embeded</a></li>
	        
				<li><a href="/tags/photo">Photograph</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/muddog" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/muddogxp/" title="weibo">weibo</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/muddog" title="zhihu">zhihu</a>
		        
					<a class="linkedin" target="_blank" href="http://www.linkedin.com/in/xinyu-chen-eric" title="linkedin">linkedin</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">豆芽</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/avatar.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">豆芽</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/tags/IoT">IoT</a></li>
		        
					<li><a href="/tags/embeded">Embeded</a></li>
		        
					<li><a href="/tags/photo">Photograph</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/muddog" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/muddogxp/" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/muddog" title="zhihu">zhihu</a>
			        
						<a class="linkedin" target="_blank" href="http://www.linkedin.com/in/xinyu-chen-eric" title="linkedin">linkedin</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-Play-With-mbedOS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      玩转mbedOS
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>mbedOS是ARM自己打造、主打IoT的一整套软件解决方案，是一个针对ARM CortexM系列处理器的嵌入式开源生态。详细的一些介绍可以参见我的另一篇文章<a href="http://muddog.pub/2016/11/12/IoT-RTOS/" target="_blank" rel="external">《IoT的那些操作系统》</a><br>从日常的工作、及和其他支持部门的交流来看，mbedOS现在还处于成长和推广阶段，在国内正真使用的客户貌似还很少，国外确实有比较牛X的客户指名道姓需要NXP的硬件来支持mbedOS。本人还是比较看好mbed，毕竟亲爹是ARM，而且提供BLE，802.15.4，6LowPAN，Thread，驱动框架及RTOS等等丰富的软件解决方案。所以么，不要等客户培养起来了再去研究，早起的鸟儿有虫吃。</p>
<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><h2 id="开发板"><a href="#开发板" class="headerlink" title="开发板"></a>开发板</h2><p>mbedOS的例子大部分都可以直接跑在NXP的FRDM-K64之上。</p>
<ul>
<li>mbed官方对板子的<a href="https://developer.mbed.org/platforms/FRDM-K64F/" target="_blank" rel="external">介绍及使用方法</a>，</li>
<li>NXP官网对板子的<a href="http://www.nxp.com/products/software-and-tools/hardware-development-tools/freedom-development-boards/freedom-development-platform-for-kinetis-k64-k63-and-k24-mcus:FRDM-K64F?fsrch=1&amp;sr=1&amp;pageNum=1" target="_blank" rel="external">介绍</a></li>
</ul>
<p>买板子，虽然mbed和NXP都可以买，但还是淘宝吧，发货快。</p>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>mbedOS支持三种开发工具：<br>1.在线IDE<br>2.mbed CLI控制台<br>3.第三方开发工具，如IAR，MDK</p>
<p>在线IDE编译很方便快捷，但没有调试功能。第三方的IDE都是可视化的，也没啥好介绍的。这里着重会来介绍mbed-cli，它的作用贯穿于整个mbed工作流：代码仓库版本控制、依赖管理、代码发布、从其他地方获取代码、调用编译系统及其他。无论你是用Windows还是Linux的主机，先准备好安装这四个工具：</p>
<ul>
<li>Python - mbed CLI 是用Python写的，并且在 version 2.7.11 上做过完整测试，不兼容Python3.x.</li>
<li><a href="https://git-scm.com/" target="_blank" rel="external">Git</a> - version 1.9.5 or later</li>
<li><a href="https://www.mercurial-scm.org/" target="_blank" rel="external">Mercurial</a> - version 2.2.2 or later</li>
<li><a href="https://launchpad.net/gcc-arm-embedded" target="_blank" rel="external">GNU ARM</a> - ARM GCC交叉编译工具</li>
</ul>
<a id="more"></a>
<p>如果你是跑在Windows上，建议使用Git-Bash。Cygwin在后期编译的时候arm-gcc会有路径错误问题。如果在Linux下，以上这些Git，Mercurial，GNUARM链接都是废话，直接仓库里下载吧。</p>
<p>通过PyPi来安装mbed-cli：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install mbed-cli</div></pre></td></tr></table></figure></p>
<p>配置下GCC的路径（你安装GNU ARM的路径）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mbed config --global GCC_ARM_PATH <span class="string">"C:\Program Files\ARM"</span></div></pre></td></tr></table></figure></p>
<h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>既然用了GNU的编译工具，GDB肯定是必不可少的调试工具。但是由于涉及到板子设备端的调试，我们还需要安装pyOCD或者OpenOCD。两者都是OCD - On Chip Debugger。都是将GDBServer协议和CMSIS-DAP的设备端调试机制集成在了一起，可以一边通过GDBServer接受GDB过来的调试请求，另一边将这些请求转换成CMSIS-DAP的SWD指令对设备端进行调试。CMSIS-DAP不多说了，基本你可以认为它是板载的调试器，用户不用购买JLINK那么贵的设备，插上USB线就可以调试板子（FRDM-K64也带了板载的CMSIS-DAP）。</p>
<h3 id="pyOCD"><a href="#pyOCD" class="headerlink" title="pyOCD"></a>pyOCD</h3><p>pyOCD是mbed官方提供的调试工具，使用Python开发，框架图如下：<br><img src="https://docs.mbed.com/docs/debugging-on-mbed/en/latest/Debugging/Images/PyOCD1.png" alt=""></p>
<p>安装方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install --pre -U pyocd</div></pre></td></tr></table></figure>
<p>但是pyOCD有个最大的缺陷，monitor的命令非常少（只支持reset, init, halt），对于调试来说手段很有限。所以这里会比较推荐OpenOCD。</p>
<h3 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h3><p>非常强大的开源OCD，支持的调试接口非常多，不局限于CMSIS-DAP，还支持包括Jlink，OSBDM，ULINK，ST-LINK等等。简单的安装方式是下载GNU ARM Eclipse OCD包：<a href="https://github.com/gnuarmeclipse/openocd/releases" target="_blank" rel="external">https://github.com/gnuarmeclipse/openocd/releases</a> 。如果从OpenOCD官网下载，你还需要编译源代码。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>串口工具装一个，方便调试。Putty, minicom，串口调试助手等都可以。</li>
<li>mbed serial，Windows串口驱动（<a href="https://developer.mbed.org/handbook/Windows-serial-configuration" target="_blank" rel="external">下载页面</a> ），Linux不需要。</li>
</ul>
<h1 id="编译系统及配置"><a href="#编译系统及配置" class="headerlink" title="编译系统及配置"></a>编译系统及配置</h1><p>mbed-cli和Android的repo有些类似。用过repo，那么你会很快熟悉mbed-cli。<br>如果你用过Makefile，那么mbed的思路有些不太一样。Makefile里可以规定当前项目的目标是什么，我要编译什么源文件，目标的依赖是什么，相对来说比较通用。mbed则比较特殊，这里简单描述下它对项目的组织方式，编译及依赖管理。</p>
<p>拿mbed-os-example-client（<a href="https://github.com/ARMmbed/mbed-os-example-client）" target="_blank" rel="external">https://github.com/ARMmbed/mbed-os-example-client）</a> 这个项目举个例子，列出主要的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">main.cpp</div><div class="line">mbed_app.json</div><div class="line">mbed_client_config.h</div><div class="line">mbed-client/</div><div class="line"> - mbed_lib.json</div><div class="line"> - module.json</div><div class="line"> - ...</div><div class="line">mbed-client.lib</div><div class="line">mbed-os/</div><div class="line"> - targets/targets.json</div><div class="line">mbed-os.lib</div><div class="line">mbedtls_mbed_client_config.h</div><div class="line">mcr20a-rf-driver/</div><div class="line">mcr20a-rf-driver.lib</div><div class="line">README.md</div><div class="line">....</div></pre></td></tr></table></figure>
<p>它有自己的源文件，放在顶层，main.cpp（当然你可以有很多个.cpp，mbed会帮你编译）。然后通过mbed_app.json描述项目的基本信息，应用的配置及目标系统的配置覆盖。怎么理解？我们先贴上mbed_app.json内容（省略了一部分）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    "config": &#123;</div><div class="line">        "network-interface":&#123;</div><div class="line">            "help": "options are ETHERNET,WIFI,MESH_LOWPAN_ND,MESH_THREAD",</div><div class="line">            "value": "ETHERNET"</div><div class="line">        &#125;,</div><div class="line">        "mesh_radio_type": &#123;</div><div class="line">                "help": "options are ATMEL, MCR20",</div><div class="line">                "value": "MCR20"</div><div class="line">        &#125;,</div><div class="line">...</div><div class="line">    &#125;,</div><div class="line">    "target_overrides": &#123;</div><div class="line">        "*": &#123;</div><div class="line">            "target.features_add": ["NANOSTACK", "LOWPAN_ROUTER", "COMMON_PAL"],</div><div class="line">            "mbed-mesh-api.6lowpan-nd-channel-page": 0,</div><div class="line">            "mbed-mesh-api.6lowpan-nd-channel": 12,</div><div class="line">            "mbed-trace.enable": 0</div><div class="line">        &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>“config”</strong> 对象里存放的是应用程序会使用到的配置，这些配置项最终会被mbed-cli转换成C语言里的宏，放到生成的mbed_config.h中，例如<strong>“mesh_radio_type”</strong>和<strong>“network-interface”</strong>，会被转换成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MBED_CONF_APP_MESH_RADIO_TYPE  MCR20 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MBED_CONF_APP_NETWORK_INTERFACE  ETHERNET</span></div></pre></td></tr></table></figure>
<p>转换规则很简单，连接符-转换成下划线，小写变大写，加上”MBED_CONF_APP” 前缀。所以在你的应用程序中，可配置项不会像常用的项目那样给用户一个.h文件，定义一些宏，让用户直接修改。而是在源文件中直接使用宏，宏的定义交给.json配置文件去写。这样的好处是通过JSON格式，可配置项变的易读，而且不用用户去创建或者修改.h文件。下面的”target_overrides”比较特殊，其实是针对mbedOS依赖项目（mbed_os/）里的设备端的软硬件配置。基本每个项目都需要用到它去覆盖某些目标设备的配置，毕竟软件还是要跑在板子上的。”target_overrides”可以选择覆盖任意，比如”*“，或者覆盖某个硬件平台配置，比如”K64”。那么这些被覆盖的配置原始定义在哪里呢？<br>对于硬件平台，target.打头的配置，可以在mbedOS的targets目录下找到：</p>
<blockquote>
<p>mbed-os/targets/targets.json</p>
</blockquote>
<p>K64的配置：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">"K64F": &#123;</div><div class="line">    "supported_form_factors": ["ARDUINO"],</div><div class="line">    "core": "Cortex-M4F",</div><div class="line">    "supported_toolchains": ["ARM", "GCC_ARM", "IAR"],</div><div class="line">    "extra_labels": ["Freescale", "KSDK2_MCUS", "FRDM", "KPSDK_MCUS", "KPSDK_CODE", "MCU_K64F"],</div><div class="line">    "is_disk_virtual": true,</div><div class="line">    "macros": ["CPU_MK64FN1M0VMD12", "FSL_RTOS_MBED"],</div><div class="line">    "inherits": ["Target"],</div><div class="line">    "detect_code": ["0240"],</div><div class="line">    "device_has": ["ANALOGIN", "ANALOGOUT", "ERROR_RED", "I2C", "I2CSLAVE", "INTERRUPTIN", "LOWPOWERTIMER", "PORTIN", "PORTINOUT", "PORTOUT", "PWMOUT", "RTC", "SERIAL", "SERIAL_FC", "SLEEP", "SPI", "SPISLAVE", "STDIO_MESSAGES", "STORAGE", "TRNG"],</div><div class="line">    "features": ["LWIP", "STORAGE"],</div><div class="line">    "release_versions": ["2", "5"],</div><div class="line">    "device_name": "MK64FN1M0xxx12"</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>在mbed_app.json里的”target.features_add”表明除了lwip, storage外，我们还需要使能mbedOS里的nanostack及6lowpan的路由功能。对于其他mbedOS相关的软件配置，例如mbed-mesh-api.打头的配置，可以在mesh网络的stack路径里找到：</p>
<blockquote>
<p>mbed-os/features/nanostack/FEATURE_NANOSTACK/mbed-mesh-api/mbed_lib.json</p>
</blockquote>
<p>这些配置都最终会以宏的形式保存在BUILD/[target]/[toolchain]/mbed_config.h文件中。当然，你选用什么样的硬件target，是在编译器选择的。</p>
<p>项目依赖则通过.lib文件来描述，.lib文件其实是一个txt文件，描述了依赖库的源码git url以及版本信息。mbed-os-example-client依赖于mbed Client客户端的应用（mbed_client.lib），依赖于mbedOS（mbed_os.lib 包括RTOS，驱动，网络协议栈），依赖于MCR20A的RF驱动（mcr20a-rf-driver.lib）。例如其中的mbed_os.lib内容如下：</p>
<blockquote>
<p><a href="https://github.com/ARMmbed/mbed-os/#d5de476f74dd4de27012eb74ede078f6330dfc3fe" target="_blank" rel="external">https://github.com/ARMmbed/mbed-os/#d5de476f74dd4de27012eb74ede078f6330dfc3fe</a></p>
</blockquote>
<p>#号后面是commit id，指定版本。对应的目录则是其源代码或者library。</p>
<p>那么对于这些库library来讲，它的编译配置及库的基本信息mbed怎么得知？和应用程序类似，我们看到mbed-client下有两个文件：</p>
<ul>
<li>module.json</li>
<li>mbed_lib.json</li>
</ul>
<p>第一个文件描述了该库的名字、版本、License、作者等等的基本信息，以及库所依赖的其他库版本。第二个文件则和应用程序的mbed_app.json一样，保存的编译配置。<br>讲到这里，你应该可以理解mbed的编译配置环境了。接下来可以Hands-on了。</p>
<h1 id="动一动手"><a href="#动一动手" class="headerlink" title="动一动手"></a>动一动手</h1><h2 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mbed import &lt;url&gt;</div></pre></td></tr></table></figure>
<p>和repo init + sync类似。URL可以是完整的git repo路径，如果只给项目名称，会直接从<a href="https://github.com/ARMmbed/" target="_blank" rel="external">https://github.com/ARMmbed/</a> 里的项目：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mbed import mbed-os-example-client</div></pre></td></tr></table></figure></p>
<p>该命令会处理模块之间的依赖关系，会检查mbed_app.json配置及.lib文件。确保所有依赖的项目源文件都被下载。如果你用git clone将mbed-os-example-client克隆下来，那么依赖库不会被同时下载，需要使用下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mbed deploy</div></pre></td></tr></table></figure></p>
<h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mbed new my-mbed-app</div></pre></td></tr></table></figure>
<p>默认会生成并下载mbedOS这个依赖库，如果需要其他库，可以用下面的命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mbed add &lt;git repo url&gt;</div></pre></td></tr></table></figure></p>
<p>mbed会自动下载，保存在子目录下，并且帮你生产.lib文件。不需要这个依赖库时，可以使用remove命令删除.lib及源文件。通过以下命令可以查看当前项目的依赖关系：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ mbed ls</div><div class="line">my-mbed-app (None)</div><div class="line">|- mbed-client (203b74116e2e)</div><div class="line">|  |- mbed-client-classic (42f18d977122)</div><div class="line">|  `- mbed-client-mbed-tls (7e1b6d815038)</div><div class="line">`- mbed-os (d5de476f74dd)</div></pre></td></tr></table></figure></p>
<p>写个简单的main.cpp，实现一个main()函数，例如点LED灯：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mbed.h"</span></span></div><div class="line"></div><div class="line"><span class="function">DigitalOut <span class="title">led1</span><span class="params">(LED1)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// main() runs in its own thread in the OS</span></div><div class="line"><span class="comment">// (note the calls to Thread::wait below for delays)</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        led1 = !led1;</div><div class="line">        Thread::wait(<span class="number">500</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>DigitalOut类实际上是GPIO输出驱动</li>
<li>Thread类是线程</li>
</ul>
<p>后面我们会讲到一些常用的API，包括设备驱动及RTOS的接口。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译需要指定target及toolchain：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mbed compile -m K64 -t GCC_ARM</div></pre></td></tr></table></figure>
<p>指定一次即可，后面可以直接使用compile编译，如果需要clean build，加上-c</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>前面的环境搭建里，安装好的pyOCD作为GDBServer，而GNU ARM Toolchain里的GDB则作为Client用来调试。</p>
<h3 id="打开调试选项"><a href="#打开调试选项" class="headerlink" title="打开调试选项"></a>打开调试选项</h3><p>首先要把编译器的-g选项打开，将debug symbol编译进elf文件。那么mbedOS里提供了对应的toolchain配置profiles：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mbed compile -c --profile mbed-os/tools/profiles/debug.json</div></pre></td></tr></table></figure></p>
<p>这个debug.json里都是编译器选项，你可以按照自己的要求修改。编译结果：./BUILD/[targe]/[toolchain]/[project].elf</p>
<h3 id="启动GDBServer"><a href="#启动GDBServer" class="headerlink" title="启动GDBServer"></a>启动GDBServer</h3><p>这里只讲OpenOCD。pyOCD比较简单，但调试用起来很不爽。首先，我们要自己为FRDM-K64写一个openOCD配置脚本，默认的release里没有。首先跑到GNU ARM Eclipse OCD安装目录下，例如：/c/Program Files/GNU ARM Eclipse/OpenOCD/0.10.0-201610281609-dev。在scripts/board/下新建一个frdm-k64.cfg，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> [find interface/cmsis-dap.cfg]</div><div class="line"></div><div class="line"><span class="comment"># increase working area to 16KB</span></div><div class="line"><span class="built_in">set</span> WORKAREASIZE 0x4000</div><div class="line"></div><div class="line"><span class="comment"># chip name</span></div><div class="line"><span class="built_in">set</span> CHIPNAME MK64FN1M0VLL12</div><div class="line"></div><div class="line">reset_config srst_only</div><div class="line"></div><div class="line"><span class="built_in">source</span> [find target/kx.cfg]</div></pre></td></tr></table></figure>
<p>然后启动OpenOCD GDBServer:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/openocd.exe <span class="_">-f</span> scripts/board/frdm-k64.cfg</div></pre></td></tr></table></figure>
<p>默认绑定本地3333端口</p>
<h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>链接到GDBServer （3333端口）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ arm-none-eabi-gdb.exe ./BUILD/K64F/GCC_ARM/mbed-os-example-client.elf</div><div class="line">GNU gdb (GNU Tools <span class="keyword">for</span> ARM Embedded Processors) 7.6.0.20140228-cvs</div><div class="line">Copyright (C) 2013 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></div><div class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</div><div class="line">This GDB was configured as <span class="string">"--host=i686-w64-mingw32 --target=arm-none-eabi"</span>.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</div><div class="line">Reading symbols from D:\mcu\iot\mbed-os-example-client\BUILD\K64F\GCC_ARM\mbed-os-example-client.elf...done.</div><div class="line"></div><div class="line">(gdb) target remote localhost:3333</div></pre></td></tr></table></figure></p>
<p>然后通过OpenOCD将程序烧入Flash：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(gdb) mointor program mbed-os-example-clinet.bin</div><div class="line">(gdb) Undefined <span class="built_in">command</span>: <span class="string">"mointor"</span>.  Try <span class="string">"help"</span>.</div><div class="line">monitor program mbed-os-example-clinet.bin</div><div class="line">MDM: Chip is unsecured. Continuing.</div><div class="line">MK64FN1M0VLL12.cpu: target state: halted</div><div class="line">target halted due to debug-request, current mode: Thread</div><div class="line">xPSR: 0x01000000 pc: 0x00000674 msp: 0x20030000</div><div class="line">** Programming Started **</div><div class="line">auto erase enabled</div><div class="line">Flash Configuration Field written.</div><div class="line">Reset or power off the device to make settings effective.</div><div class="line">wrote 65536 bytes from file mbed-os-example-clinet.bin <span class="keyword">in</span> 3.757346s (17.033 KiB/s)</div><div class="line">** Programming Finished **</div></pre></td></tr></table></figure></p>
<p>注意，这里的mbed-os-example-clinet.bin是同elf文件在编译时候一起生成的，你需要拷贝到跑openocd的目录下，否则会报错找不到文件。</p>
<p>接着，reset target，让硬件重新复位：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) monitor reset init</div></pre></td></tr></table></figure></p>
<p>接下来就可以用GDB的其他调试命令来调试了，这里就不多说。</p>
<h1 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h1><p>mbedOS的接口都是以C++的接口形式实现，也就是说对于某一类对象或者操作都会封装成类。所以API都是以类函数和静态函数提供。当然重载的操作符Operator，例如=，()，+/-都是很常见的，它可以非常直观的操作设备和对象。</p>
<p>mbedOS提供以下几种类型的API：</p>
<blockquote>
<ul>
<li>Task management: handling tasks and events in mbed OS.</li>
<li>Inputs and outputs: analog, digital, bus, port, PwmOut and interrupts.</li>
<li>Digital interfaces: serial, SPI, I2C and CAN.</li>
<li>Communication: network sockets, Ethernet, WiFi and BLE.</li>
<li>Security: working with mbed uVisor and mbed TLS in the context of mbed OS.</li>
</ul>
</blockquote>
<h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><ul>
<li>Thread任务管理类，进程间通讯类（互斥体 Mutex、信号量 Samaphore、信号 Signal、邮箱 Mail、队列 Queue），及RtosTimer内核时钟定时器类</li>
<li>EventLoop事件回环类，主要用途是使得中断触发的事件处理可以在用户上下文中执行，而不是在IRQ里占用大量资源。说白了，就是在IRQ里触发一个事件，将等待该事件队列中的任务唤醒，来处理事件。</li>
<li>Time日期时间类</li>
<li>Ticker周期性定时器类</li>
<li>TimeOut超时定时器类</li>
<li>Timer时间间隔计量类</li>
<li>Wait延时类（忙等待延时）</li>
</ul>
<h2 id="输入、输出设备"><a href="#输入、输出设备" class="headerlink" title="输入、输出设备"></a>输入、输出设备</h2><p>主要分为三类pin：模拟，数字和PWM。在实际的芯片上，你可以认为</p>
<ul>
<li>AnalogIn是ADC采样类，AnalogOut是DAC模拟输出类</li>
<li>DigitalIn/Out是GPIO的输入输出类</li>
<li>BusIn/Out是自定义的一组GPIO操作的类</li>
<li>PortIn/Out则是对于某一组GPIO的所有组内的GPIO操作的类</li>
<li>PwmOut则是PWM模块的方波输出类</li>
<li>InterruptIn则是将GPIO配置成输入产生中断的类</li>
</ul>
<h2 id="数字接口"><a href="#数字接口" class="headerlink" title="数字接口"></a>数字接口</h2><p>很简单，分成：</p>
<ul>
<li>Serial, UART类</li>
<li>SPI/SPISlave 类</li>
<li>I2C/I2CSlave 类</li>
<li>CAN 类</li>
</ul>
<h2 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h2><ul>
<li>网络Sockets，标准的Socket接口，只是以C++封装</li>
<li>以太网，连接，获取MAC地址等的接口</li>
<li>WiFi，进行scan,连接到指定SSID等的接口</li>
<li>BLE，一套完整的BLE类接口（<a href="https://docs.mbed.com/docs/mbed-os-api-reference/en/5.1/APIs/communication/ble/）" target="_blank" rel="external">https://docs.mbed.com/docs/mbed-os-api-reference/en/5.1/APIs/communication/ble/）</a> 和上面的三类接口比起来相对独立。以太网、Wifi只是对网络设备的基本操作，之后都可以走socket做通讯。</li>
</ul>
<h2 id="安全（C接口）"><a href="#安全（C接口）" class="headerlink" title="安全（C接口）"></a>安全（C接口）</h2><ul>
<li>mbed uVisor，利用MPU来创建沙箱保护memory map上的指定的内存、设备区域；利用Cortex的SVCall将操作系统、中断处理的权限提升。具体的还没研究。等下一篇内核分析吧。</li>
<li>mbed TLS，常用于嵌入式的TLS库（原PolarSSL）接口</li>
</ul>
<p>所有的这些API都可以在这里找到：<a href="https://docs.mbed.com/docs/mbed-os-api-reference/en/5.3/" target="_blank" rel="external">mbedOS API 参考手册</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/25/Play-With-mbedOS/" class="archive-article-date">
  	<time datetime="2016-11-25T12:54:39.490Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-25</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IoT/">IoT</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RTOS/">RTOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mbed/">mbed</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mbedOS/">mbedOS</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/12/10/Sunshine-Hangzhou/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          枫叶红了...你慢慢长大
        
      </div>
    </a>
  
  
    <a href="/2016/11/20/DTLS-Analysis/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">借助mbedTLS了解DTLS握手协议</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Play-With-mbedOS" data-title="玩转mbedOS" data-url="http://muddog.github.io/2016/11/25/Play-With-mbedOS/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"muddog"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 豆芽
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Blocking/" style="font-size: 10px;">Blocking</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Clocksource/" style="font-size: 10px;">Clocksource</a> <a href="/tags/DTLS/" style="font-size: 10px;">DTLS</a> <a href="/tags/Embeded/" style="font-size: 10px;">Embeded</a> <a href="/tags/FTP/" style="font-size: 10px;">FTP</a> <a href="/tags/Family/" style="font-size: 10px;">Family</a> <a href="/tags/HRTimer/" style="font-size: 10px;">HRTimer</a> <a href="/tags/Hangzhou/" style="font-size: 10px;">Hangzhou</a> <a href="/tags/IoT/" style="font-size: 15px;">IoT</a> <a href="/tags/Kernel/" style="font-size: 17.5px;">Kernel</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/Memory/" style="font-size: 10px;">Memory</a> <a href="/tags/Netfilter/" style="font-size: 12.5px;">Netfilter</a> <a href="/tags/Photography/" style="font-size: 10px;">Photography</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/QT/" style="font-size: 10px;">QT</a> <a href="/tags/RTOS/" style="font-size: 12.5px;">RTOS</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Thread/" style="font-size: 12.5px;">Thread</a> <a href="/tags/Timekeeping/" style="font-size: 10px;">Timekeeping</a> <a href="/tags/Yocto/" style="font-size: 10px;">Yocto</a> <a href="/tags/buddy/" style="font-size: 10px;">buddy</a> <a href="/tags/handshake/" style="font-size: 10px;">handshake</a> <a href="/tags/i-MX6/" style="font-size: 10px;">i.MX6</a> <a href="/tags/mbed/" style="font-size: 10px;">mbed</a> <a href="/tags/mbedOS/" style="font-size: 10px;">mbedOS</a> <a href="/tags/mbedTLS/" style="font-size: 10px;">mbedTLS</a> <a href="/tags/豆芽保姆/" style="font-size: 10px;">豆芽保姆</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">土狗一只&lt;br&gt;&lt;br&gt;码农&lt;br&gt;嵌入式</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>